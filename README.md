# 华中科技大学自动化学院C语言课程设计
# 照片管理与编辑系统

## 照片管理与编辑系统需求分析报告
小组成员：	王子毅 牛宝健

 








 

## 引言
#### 1.1 编写目的
通过一定量的有关 “照片管理与编辑系统”的需求者和使用者的调查与分析，以及通过使用已有的照片管理与编辑系统和网上资料查询，在对项目可行性和功能的详细分析和纠正的基础上，特提出了这份软件需求分析和系统设计报告。
此份需求分析与系统设计报告对“照片管理与编辑系统”项目做了全面的用户需求分析，明确此所要开发的软件应具有的功能、性能与界面，设计了程序流程，使系统分析人员及软件开发人员能清楚地了解用户的需求，并在此基础上进一步提出系统设计报告和完成后续设计与开发工作。本报告的预期读者为项目委托部门、业务或需求分析人员、测试人员。
#### 1.2 背景
当今时代是信息化时代，而信息的数字化也越来越为研究人员所重视。数码照片是数字化的摄影作品，通常指采用数码相机进行创作的摄影作品。数字图像处理(Digital Image Processing)是通过计算机对图像进行去除噪声、增强、复原、分割、提取特征等处理的方法和技术。照片管理与编辑系统主要处理以像素所构成的数字图像，使用众多的编修与修饰工具，可以有效地进行图片编辑工作。
#### 1.3 参考资料
	王士元. C高级实用程序设计. 北京: 清华大学出版社. 1996

	周纯杰，刘正林等. 标准C语言程序及应用. 武汉: 华中科技大学出版社. 2008

	VESA BIOS EXTENSION (VBE) Core Function Standard Version: 2.0 Document Revision: 1.1 Ratification Date: November 18, 1994
## 任务概述 
#### 2.1 目标
本产品可实现“照片管理与编辑系统”的基本功能。产品用户可在最开始的界面进打开或新建照片。普通用户使用该软件可进行的操作：打开照片、保存照片、新建照片、调用图库、编辑照片、裁剪照片、绘制图形、调节画笔颜色、调节画笔粗细、调节图形粗细、旋转照片、翻转照片、放大照片、缩小照片、调整照片色相饱和度亮度、制作滤镜。
#### 2.2 用户的特点
本系统操作简单界面美观逻辑清晰。面向的用户是广大的照片编辑者，只要具备计算机的基本使用技能和照片编辑的思路就可以使用该系统，用户进入该系统时，按照指示窗口进行操作，即可完成照片管理、修饰、编辑的全过程。对于维护人员，需要对C语言和数据结构有一定的了解，以便于在软件出错时及时维护软件，并可以根据需要增添相关的功能。预计该系统投入市场后反应较好，会得到消费者以及项目开发人员的肯定与支持。 
需求规定
#### 3.1照片管理模块
###### 1.	文件打开
输入文件名称，打开文件。
如果文件名称输入正确并且文件类型符合要求，则正常打开图像；否则，弹出报错窗口。

###### 2.	文件保存
输入文件名称，保存文件。
如果已有图像打开并且输入的文件名称未超出字符长度限制，则正常保存图像；否则，弹出报错窗口。

###### 3.	文件新建
输入尺寸，选择颜色，新建该尺寸、该色彩的图像。
1)	输入新建图像的尺寸：图像的长度以及图像的宽度（单位：像素）。
a)	如果没有输入尺寸，则选择默认尺寸（400像素×300像素）。
b)	如果尺寸不符合要求，则弹出警告；
2)	选择新建图像的填充色。
a)	如果没有选择颜色，则选择默认颜色（灰白色）。

###### 4.	图库
点击文件，查看文件信息，打开或删除文件。 
1)	显示基本信息：文件名称、文件类型、修改时间、图像长度、图像宽度。
2)	显示照片缩略图。
3)	点击“打开”按钮，直接打开图片。
4)	点击“删除”按钮，直接删除文件。

#### 3.2照片编辑及修饰模块
###### 1.	画笔
通过画笔对图像进行修饰。
1)	在图像有效区域，可以绘制。 
2)	在图像区域外，不能绘制。
3)	可以调用选色、粗细调整功能修改画笔的属性。

###### 2.	裁剪
裁剪图像。
1)	检测用户是否打开图像，如果没有，则提醒用户。
2)	如果裁剪后的图像太小，则提醒用户是否要裁剪。

###### 3.	放大
点击“放大”按钮，可对图像放大。
如果图像过大，或已经放到最大程度，则不进行图像缩小处理。

###### 4.	缩小
点击“缩小”按钮，可对图像缩小。
如果图像过小，或已经缩小到最小程度，则不进行图像缩小处理。

###### 5.	旋转
点击“旋转”按钮，将图像逆时针旋转90度。
如果旋转后的图像超出工作区域，则旋转操作无效。

###### 6.	镜像
点击“镜像”按钮，将图像沿中心竖直线翻转。

###### 7.	调整
调整图像的对比度、饱和度和亮度。

###### 8.	滤镜
点击“滤镜”按钮，选择两种颜色作为滤镜的起始色和终止色，点击“确认”后将为当前图片加上滤镜。（若图片未打开，会提醒用户）

###### 9.	图形
点击“图形”按钮，将出现“直线”、“三角形”、“矩形”、“圆”四种图形框，选择一个功能，即可在图片上绘制相应的图案。
1)	进入子功能后，只有再次点击正在执行的功能按钮时，才会回到主功能（图形）。
2）当从图形功能切换至其他功能后，将收起四个图形框。
3）在图像有效区域，可以绘制。 
4)	在图像区域外，不能绘制。

###### 10.	拾色器
点击“拾色器”按钮，可以拾取除功能按钮外其他任何界面的当前颜色，并将其作为现在的颜色值。（不允许在拾色器状态下退出程序，即点击“退出”按钮仍进行拾色操作）

#### 3.3工具设置模块
###### 1.	粗细大小
设置画笔的大小和图形的粗细。
1)	画笔的大小和图形的粗细具有最大值（分别为8，5）。
2)	画笔的大小和图形的粗细具有默认值（分别为5，1）。

###### 2.	选色
通过调色板设置画笔、图形等工具的颜色。
1)	调色板分为两个主要部件：色相-饱和度面板，亮度面板。
2)	调色板会以RGB数值的形式显示用户当前选择的颜色信息。
例如：R:125 G:155 B:176。
3)	调色板可以选择的颜色多达16,777,216‬ 种颜色（256*256*256）。

3.	放缩模式
设置图像的放缩模式：双线性插值法、临近点插值法（默认）。

 

## 运行环境规定 
#### 4.1 设备 
本系统是对“图片管理与编辑系统”基本模拟，因此，对此系统的运行环境将是在计算机上面进行，即在电脑上模拟实现，系统运行的设备需求如下:
1)	一台 586 以上的微机及兼容  
2)	内存 16MB 及其以上  
3)	彩色显示器一台 
#### 4.2 支持软件 
根据“图片管理与编辑系统”设计环境要求，即在 DOS 环境下，用 C 语言编译实现，使用 TC 或 BC 开发软件，因此，此模拟系统可在绝大多数现形计算机系统上运行，包括最常见的 Windows XP 操作系统以及 Windows 7 32 位机上运行，但由于兼容性问题，此“证券量化投资系统”在windows 7 64 位操作系统的计算机上运行可能出现意想不到的问题或根本不能运行，因而，不推荐在包含 64 位操作系统的计算机上测试本系统。
#### 4.3 接口 
1)	用户接口:本系统采用一般性架构，所有界面使用简易风格。 
2)	硬件接口:无特殊要求。
3)	软件接口:无特殊要求。
4)	通信接口:无特殊要求。 
#### 4.4 控制 
本系统主要通过鼠标直接进行操控，部分内容可以通过键盘操作。用户将鼠标移至需要操作的功能区点击，进行相应的操作，操作进行完后，点击相应位置退出系统。控制信号来源于用户鼠标的位置，以及用户使用鼠标进行的操作。 
 
## 系统设计
#### 5.1 功能设计详细描述 
#### 5.1.1 照片管理模块
###### 1.	打开
1)	调用：
点击“打开”图标，弹出“打开”窗口。
2)	设置快捷键及其他键：
a)	ESC键关闭窗口。
b)	Enter键打开图片。
c)	Backspace键删除字符。
3)	打开图片：
a)	如果不存在指定文件则弹出警告窗口。
b)	如果指定文件类型不符弹出警告窗口。
c)	正常情况关闭“打开”窗口并打开图片。
4)	关闭：
点击“关闭”图标关闭窗口。

###### 2.	保存
1)	调用：
①如果工作区域已有图像打开，弹出“保存”窗口。
②如果工作区域没有图像打开，弹出“未图片打开”警告。
2)	设置快捷键：
a)	ESC键关闭窗口。
b)	Enter键保存图片。
c)	Backspace键删除字符。
3)	保存图片：
点击“确认”按钮，保存图片。
4)	关闭：
点击“关闭”图标，关闭窗口。

###### 3.	新建
1)	调用：
点击“新建”图标，弹出“新建”窗口。
2)	设置快捷键：
a)	ESC键关闭窗口。
b)	Enter键新建图像。
c)	Backspace键删除数字。
d)	Tab键切换输入框。（宽度输入框和高度输入框）。
3)	输入尺寸：
点击“宽度”输入框，宽度输入框被聚焦。
点击“高度”输入框，高度输入框被聚焦。
4)	选择颜色：
点击“选色”按钮，弹出调色板窗口，选择颜色。
5)	新建图片：
a)	如果输入的宽度不符合要求，弹出“宽度超出或不足”警告窗口。
b)	如果输入的高度不符合要求，弹出“高度超出或不足”警告窗口。
c)	如果未进行选色操作，则选择默认填充色（灰白色）。
d)	如果未输入尺寸，则使用默认尺寸（400像素*300像素）。
6)	关闭：
点击“关闭”图标，关闭窗口。

###### 4.	图库
1)	调用：
点击“图库”图标，弹出“照片管理”窗口。
2)	显示文件列表：
显示文件夹中的部分文件。（如果文件数量不多，则显示全部）。
3)	加载文件信息：
点击文件列表中的文件，显示文件信息：
i.	文件名称
ii.	文件类型
iii.	文件大小（单位：KB）
iv.	修改日期（包括：年、月、日、时、分、秒）
v.	图像尺寸（包括：图像宽度、图像高度，单位：像素）。
4)	显示照片缩略图：
点击文件列表中的文件，显示图片的缩略图。
5)	翻动文件列表：
点击“上翻”按钮向上翻动文件列表。
点击“下翻”按钮向下翻动文件列表。
6)	打开图片：
点击“打开”按钮打开图片。
7)	删除图片：
点击“删除”按钮删除文件。
8)	关闭：
点击“关闭”图标，关闭窗口。

#### 5.1.2 照片编辑及修饰模块
###### 1.	画笔
1)	调用：
点击“画笔”图标，启动画笔功能。
如果图像未打开，画笔功能无法启动。
2)	绘制：
在图像区域内点击，开始绘制。
如果不在图像有效区域内点击，绘制无效。
3)	退出：
再次点击“画笔”图标退出画笔功能。
如果直接点击其他功能按钮，将会直接切换至对应功能。

###### 2.	裁剪
1)	点击“裁剪”图标，启动“裁剪”功能。
如果图像未打开，裁剪功能无法启动。
2)	在图像区域内按下鼠标左键记录坐标(X1,Y1)。
如果不在图像有效区域内点击鼠标，记录无效。
3)	拖动鼠标移至图像内另一点。
4)	松开鼠标左键，记录坐标（X2，Y2）。
如果已经移除鼠标有效区域，则记录无效。
5)	对图像进行裁剪，保留两坐标以内的内容，其余内容删去。
6)	再次点击“裁剪”图标退出画笔功能。
7)	如果直接点击其他功能按钮，将会直接切换至对应功能。

###### 3.	放大
1)	调用：
点击“放大”图标，进行图像放大处理。
2)	放大功能：
如果工作界面没有图像打开，则操作无效，并提醒用户。
如果图像放大后超出上限，则操作无效，并提醒用户。
正常情况下，以1.25倍率放大原图像。

###### 4.	缩小
1)	调用：
点击“缩小”图标，进行图像缩小处理。
2)	缩小功能：
如果工作区域没有图像打开，则操作无效。
如果图像缩小后超出下限，则操作无效。
正常情况下，以0.80倍率缩小原有图像。


###### 5.	旋转
1)	调用：
点击“旋转”图标，进行图像旋转处理。
2)	旋转功能：
如果工作区域没有图像打开，则操作无效。
如果旋转后的图像，宽度或高度超出限制范围，则操作无效。
正常情况下，图像进行逆时针旋转90度。

###### 6.	镜像
1)	调用：
点击“镜像”图标，进行图像镜像处理。
2)	镜像功能：
如果工作区域没有图像打开，则操作无效。
理论上，不存在镜像后图像长宽超出限制范围的情况。
正常情况下，图像进行垂直镜像。
###### 7.	调整
1)	调用：
点击“调整”图标，弹出“图像调整”窗口。
2)	饱和度调整：
拖动饱和度滑槽，饱和度数值改变。
3)	对比度调整：
拖动对比度滑槽，对比度数值改变。
4)	亮度调整：
拖动亮度滑槽，亮度数值改变。
5)	确认：
点击“确认”按钮，依次调节对比度、饱和度、亮度。
6)	取消：
关闭窗口，不调整图像的色彩。

###### 8.	图形
1)	显示菜单：
点击“图形”按钮，显示出“直线”、“三角形”、“矩形”、“圆”四个子功能菜单。
2)	调用：
点击任意一子功能执行对应的操作。
a)	直线：
点击图片内一个点作为直线的一个端点，记录坐标（X1,Y1）。
点击图片内另一个点作为直线的另一个端点，记录坐标（X2,Y2）。
画出直线。
再次点击“直线”按钮，退出子功能。
点击其他按钮（主功能除外），可直接调用相应的功能。
b)	三角形：
点击图片内一个点作为三角形的一个顶点，记录坐标（X1,Y1）。
点击图片内第二个点作为三角形的第二个顶点，记录坐标（X2,Y2）。
点击图片内第三个点作为三角形的第三个顶点，记录坐标（X3,Y3）。
画出三角形。
再次点击“三角形”按钮，退出子功能。
点击其他按钮（主功能除外），可直接调用相应的功能。
c)	矩形：
点击图片内一个点作为矩形的一个顶点，记录坐标（X1,Y1）。
点击图片内另一个点作为矩形的对角端点，记录坐标（X2,Y2）。
画出矩形。
再次点击“矩形”按钮，退出子功能。
点击其他按钮（主功能除外），可直接调用相应的功能。
d)	圆：
点击图片内一个点作为圆心，记录坐标（X1,Y1）。
点击图片内另一个点，将这两点间的距离作为半径，记录半径r。
画出圆。（若半径过大超出图片则不画出）
再次点击“圆”按钮，退出子功能。
点击其他按钮（主功能除外），可直接调用相应的功能。
3)	退出：
再次点击“图形”图标退出图形功能。

###### 9.	滤镜
1）	调用：
点击“滤镜”按钮，弹出提示框。
   如果图像未打开，滤镜功能无法启动。
2）	设置渐变色：
点击颜色一，选择滤镜的起始颜色（默认蓝色）。
点击颜色二，选择滤镜的终止颜色（默认粉色）。
3）	点击“确认”，生成图像滤镜。
   点击“取消”或“关闭”，退出滤镜功能。

###### 10.	拾色器
1）	调用：
点击“拾色器“图标，将显示当前颜色及其RGB值。
2）	拾取颜色：
点击屏幕内的非功能键（退出除外）处，将该处的颜色值作为新的颜色值。
3）	退出：
再次点击“图形”图标退出图形功能。

#### 5.1.2 工具设置模块
###### 1.	粗细大小
1)	调用：
点击“粗细”图标，弹出“粗细调整”窗口。
2)	调节画笔大小：
点击“画笔粗细”后的“+”，画笔大小增加。
点击“画笔粗细”后的“-”，画笔大小减少。
默认画笔大小为5，最大值为8，最小值为1。
3)	调节图形粗细：
点击“线条粗细”后的“+”，线条宽度增加。
点击“线条粗细”后的“-”，线条宽度减少。
默认线条粗细为1，最大值为5，最小值为1。
4)	确认：
点击“确认”按钮，保存本次修改后的粗细值，并退出窗口。
5)	关闭：
点击“取消”按钮，不保存修改值，关闭窗口。
点击“关闭”图标，不保存修改值，关闭窗口。。

###### 2.	选色
1)	调用：
点击“选色”图标，弹出“选色”窗口。
2)	选色：
选色窗口包含两个面板（色相-饱和度面板、亮度面板），两个信息输出框（RGB色彩信息框、呈色框）组成。 
a)	色相-饱和度面板：横向为色相轴（0~180），纵向为饱和度轴（0~100）。鼠标点击色相-饱和度面板，会触发程序捕获相应的色相（H）、饱和度（S）数值，并将HSL变量（亮度L默认为0.5）转换为RGB变量。
b)	亮度面板：纵向为亮度轴（0~100）。鼠标点击亮度面板，会触发程序捕获相应的亮度（L），并将HSL变量（H、S默认为0）转换为RGB变量。
c)	RGB色彩信息框：在每次色彩空间转换完成后，RGB变量将会格式化输出到色彩信息框内，以便用户更充分地了解色彩信息。
d)	呈色框：在每次色彩空间转换完成后，呈色框将呈现出所选颜色，以便用户更直接地获得所选颜色信息。
3)	确认：
点击“确认”按钮，保存所选颜色，关闭窗口。
4)	关闭：
点击“关闭”图标，不保存修改值，关闭窗口。

###### 3.	放缩模式
1)	调用：
点击“设置”图标，弹出“模式”窗口。
默认情况下选择临近点插值法。
2)	确认：
点击“确认”按钮，保存选择的模式，并关闭窗口。
3)	关闭：
点击“取消”按钮，放弃选择的模式，并关闭窗口。
点击“关闭”图标，放弃选择的模式，并关闭窗口。

 
#### 5.2	界面设计
1.	欢迎界面
 
欢迎界面由标题和背景组成，标题使用汉字库制作，背景使用渐变函数制作（无贴图），界面内有动画显示。
2.	工作界面
 
工作界面由各种工具以及中心工作区域组成。用户在工作界面内可以打开图像，编辑图像，使用工具等等。
3.	图库窗口
 
照片管理窗口由文件列表、信息框、缩略图、打开按钮、删除按钮组成。
4.	打开窗口
 
打开窗口由输入框、提示框、确认按钮组成。
5.	保存窗口
 
保存窗口由输入框、提示框、确认按钮组成。
6.	新建窗口
 
新建窗口由宽度输入框、高度输入框、确认按钮、选色按钮组成。
 
7.	粗细调整窗口
 
粗细调整窗口由画笔粗细调整按钮、图形粗细调整按钮、确认按钮、取消按钮组成。
8.	选色窗口
 
调色板窗口由色相-饱和度面板、亮度面板、RGB信息面板、呈色面板组成。
9.	放缩模式窗口
 
放缩模式窗口由模式选项部件、确认按钮、取消按钮组成。
10.	警告窗口
 
警告窗口由警告信息、确认按钮、取消按钮组成。
11.	滤镜窗口
 
滤镜窗口由颜色一、颜色二及确认、取消按钮组成。
12.	调整窗口
 
调整窗口由对比度、饱和度、亮度调整部件组成。
 
13.	效果展示

通过点击不同的功能图标，可实现不同的功能。
 
#### 5.3	软件结构
###### 5.3.1文件结构

文件信息描述：

BMP·········································图像储存区域
DATA·········································为数据处理区域
INCLUDE······································包含头文件
OUTPUT······································程序生成文件
SOURCR······································源文件代码
UI···········································图形界面
ZK···········································汉字库文件
###### 5.3.2库级关系
  
###### 5.3.3消息机制
 
###### 5.3.4功能使用
 
## 算法
#### 6.1色彩空间转换算法
 
图一：   左图： RGB模型          右图： HSL模型
###### 从 RGB 到 HSL 的转换
 
1.	int RGB2HSL(RGB rgb, HSL* hsl)  
2.	{  
3.	    double rr, gg, bb;  
4.	    double Max, Min;  
5.	    int* h = &hsl->h;  
6.	    double* s = &hsl->s;  
7.	    double* l = &hsl->l;  
8.	  
9.	    rr = (double)rgb.r / 255.0;  
10.	    gg = (double)rgb.g / 255.0;  
11.	    bb = (double)rgb.b / 255.0;  
12.	  
13.	    Max = rr;  
14.	    if (Max < gg)  
15.	    {  
16.	        Max = gg;  
17.	    }  
18.	    if (Max < bb)  
19.	    {  
20.	        Max = bb;  
21.	    }  
22.	  
23.	    Min = rr;  
24.	    if (Min > gg)  
25.	    {  
26.	        Min = gg;  
27.	    }  
28.	    if (Min > bb)  
29.	    {  
30.	        Min = bb;  
31.	    }  
32.	  
33.	    //计算亮度  
34.	    *l = (Max + Min) / 2.0;  
35.	  
36.	    //计算色相  
37.	    if (Max == Min)  
38.	    {  
39.	        *h = 0;  
40.	  
41.	    }  
42.	    else if (Max == rr && gg >= bb)  
43.	    {  
44.	        *h = 60 * (gg - bb) / (Max - Min) + 0;  
45.	    }  
46.	    else if (Max == rr && gg < bb)  
47.	    {  
48.	        *h = 60 * (gg - bb) / (Max - Min) + 360;  
49.	    }  
50.	    else if (Max == gg)  
51.	    {  
52.	        *h = 60 * (bb - rr) / (Max - Min) + 120;  
53.	    }  
54.	    else if (Max == bb)  
55.	    {  
56.	        *h = 60 * (rr - gg) / (Max - Min) + 240;  
57.	    }  
58.	    else  
59.	    {  
60.	        return 0;  
61.	    }  
62.	  
63.	  
64.	    //计算饱和度  
65.	    if (*l == 0 || Max == Min)  
66.	    {  
67.	        *s = 0;  
68.	    }  
69.	    else if (*l > 0 && *l <= 0.5)  
70.	    {  
71.	        *s = (Max - Min) / (Max + Min);  
72.	    }  
73.	    else if (*l > 0.5)  
74.	    {  
75.	        *s = (Max - Min) / (2 - (Max + Min));  
76.	    }  
77.	    else  
78.	    {  
79.	        return 0;  
80.	    }  
81.	  
82.	    return 1;  
83.	}  
###### 从 HSL 到 RGB 的转换
 
1.	int HSL2RGB(RGB* rgb, HSL hsl)  
2.	{  
3.	    double tR, tG, tB;  
4.	    double p, q;  
5.	    double hk;  
6.	    u8* r = &rgb->r;  
7.	    u8* g = &rgb->g;  
8.	    u8* b = &rgb->b;  
9.	  	
10.		   //如果S为0，则为灰度图
11.	    if (hsl.s == 0)  
12.	    {  
13.	        tR = hsl.l;  
14.	        tG = hsl.l;  
15.	        tB = hsl.l;  
16.	    }  
17.	    else  
18.	    {  
19.	        if (hsl.l < 0.5)  
20.	        {  
21.	            q = hsl.l * (1.0 + hsl.s);  
22.	        }  
23.	        else  
24.	        {  
25.	            q = hsl.l + hsl.s - (hsl.l * hsl.s);  
26.	        }  
27.	        p = 2.0 * hsl.l - q;  
28.	        hk = (double)hsl.h / 360.0;  
29.	        tR = hk + 1.0 / 3.0;  
30.	        tG = hk + 0;  
31.	        tB = hk - 1.0 / 3.0;  
32.	        tR = ToRGB(p, q, tR);  
33.	        tG = ToRGB(p, q, tG);  
34.	        tB = ToRGB(p, q, tB);  
35.	    }  
36.	    *r = (int)(tR * 255.0 + 0.5);  
37.	    *g = (int)(tG * 255.0 + 0.5);  
38.	    *b = (int)(tB * 255.0 + 0.5);  
39.	    return 1;  
40.	}  
41.	  
42.	double ToRGB(double p, double q, double tC)  
43.	{  
44.	    double ColorC;  
45.	    if (tC < 0)  
46.	    {  
47.	        tC = tC + 1.0;  
48.	    }  
49.	    else if (tC > 1)  
50.	    {  
51.	        tC = tC - 1.0;  
52.	    }  
53.	    else  
54.	    {  
55.	        ;  
56.	    }  
57.	    if (tC < (1.0 / 6.0))  
58.	    {  
59.	        ColorC = p + ((q - p) * 6 * tC);  
60.	    }  
61.	    else if (tC >= (1.0 / 6.0) && tC < 0.5)  
62.	    {  
63.	        ColorC = q;  
64.	    }  
65.	    else if (tC >= 0.5 && tC < (2.0 / 3.0))  
66.	    {  
67.	        ColorC = p + ((q - p) * 6 * (2.0 / 3.0 - tC));  
68.	    }  
69.	    else  
70.	    {  
71.	        ColorC = p;  
72.	    }  
73.	  
74.	    return ColorC;  
75.	}  
 
#### 6.2图像放缩算法
###### 双线性内插法

图二：双线性内插法   
 
图三：双线性内插法效果

###### 临近点插值法
 
图四：临界点插值法
 
图五：临界点插值法效果图

1.	u32 ImageInterpolat(int x1, int x2, int y1, int y2, double x, double y, u8 patton)  
2.	{  
3.	    int i;  
4.	    u32 color[4];  
5.	    RGB rgb[4];  
6.	    double r1,r2,r,g1,g2,g,b1,b2,b;  
7.	  
8.	    color[0] = GetPixel(x1, y1);  
9.	    color[1] = GetPixel(x2, y1);  
10.	    color[2] = GetPixel(x1, y2);  
11.	    color[3] = GetPixel(x2, y2);  
12.	  
13.	    for (i = 0; i < 4; i++)  
14.	    {  
15.	        rgb[i].r = (u8)((color[i] & 0xff0000) >> 16);  
16.	        rgb[i].g = (u8)((color[i] & 0x00ff00) >> 8);  
17.	        rgb[i].b = (u8)((color[i] & 0x0000ff));  
18.	    }  
19.	  
20.	    if (patton)  
21.	    {  
22.	        //双线性内插法  
23.	        r1 = ((x2 - x) * rgb[0].r + (x - x1) * rgb[1].r) / (x2 - x1);  
24.	        r2 = ((x2 - x) * rgb[2].r + (x - x1) * rgb[3].r) / (x2 - x1);  
25.	        r = ((y2 - y) * r1 + (y - y1) * r2) / (y2 - y1);  
26.	        g1 = ((x2 - x) * rgb[0].g + (x - x1) * rgb[1].g) / (x2 - x1);  
27.	        g2 = ((x2 - x) * rgb[2].g + (x - x1) * rgb[3].g) / (x2 - x1);  
28.	        g = ((y2 - y) * g1 + (y - y1) * g2) / (y2 - y1);  
29.	        b1 = ((x2 - x) * rgb[0].b + (x - x1) * rgb[1].b) / (x2 - x1);  
30.	        b2 = ((x2 - x) * rgb[2].b + (x - x1) * rgb[3].b) / (x2 - x1);  
31.	        b = ((y2 - y) * b1 + (y - y1) * b2) / (y2 - y1);  
32.	    }  
33.	  
34.	    else  
35.	    {  
36.	        //最邻近点插值法  
37.	        if (x >= x1 && x <= x1 + 0.5 && y >= y1 && y <= y1 + 0.5)  
38.	        {  
39.	            r = rgb[0].r;  
40.	            g = rgb[0].g;  
41.	            b = rgb[0].b;  
42.	        }  
43.	        else if (x > x1 + 0.5 && x <= x2 && y >= y1 && y <= y1 + 0.5)  
44.	        {  
45.	            r = rgb[1].r;  
46.	            g = rgb[1].g;  
47.	            b = rgb[1].b;  
48.	        }  
49.	        else if (x >= x1 && x <= x1 + 0.5 && y > y1 + 0.5 && y <= y2)  
50.	        {  
51.	            r = rgb[2].r;  
52.	            g = rgb[2].g;  
53.	            b = rgb[2].b;  
54.	        }  
55.	        else if (x > x1 + 0.5 && x <= x2 && y > y1 + 0.5 && y <= y2)  
56.	        {  
57.	            r = rgb[3].r;  
58.	            g = rgb[3].g;  
59.	            b = rgb[3].b;  
60.	        }  
61.	        else  
62.	        {  
63.	            return 0;  
64.	        }  
65.	    }  
66.	  
67.	    return RGB2U32(r, g, b); 
68.	}  
 
#### 6.3图像调节算法
###### 对比度调节算法

图六：对比度函数的图像

对比度实现的原理：
	对比度调节函数通过模拟“S”型曲线，改变图像的色彩值：如果contrast < 0，则图像中小与阈值（127）的像素的值将增加，大于阈值的像素的值将减小；如果contrast > 0，则图像中小于阈值（127）的像素的值将减小，大于阈值的像素的值将增加；如果contrast = 0，则图像不变。
	对比度调节的过程分为两步：第一步，判断当前图像的对比度是否为零，如果不为零，通过逆向变换得到对比度为零时的原图；如果为零，则直接进入第二步。第二步，通过正向变化得到调整后的图像。
	对比度调节公式见下：
  
图七：对比度调节效果图

1.	int ImageContrast(BMPATTR attr,int value)  
2.	{  
3.	    int i, j;       //循环变量  
4.	    u32 oldcolor;   //色彩变量  
5.	    RGB rgb;        //色彩分量  
6.	  
7.	    if (value >= -50 && value <= 50)  
8.	    {  
9.	        for (i = attr.y1; i < attr.y2; i++)  
10.	        {  
11.	            for (j = attr.x1; j < attr.x2; j++)  
12.	            {  
13.	                oldcolor = GetPixel(j, i);  
14.	                U32TRGB(&rgb, oldcolor);  
15.	                //计算公式  
16.	                rgb.r = ContrastCalc(rgb.r, value);  
17.	                rgb.g = ContrastCalc(rgb.g, value);  
18.	                rgb.b = ContrastCalc(rgb.b, value);  
19.	                //类型转换  
20.	                oldcolor = RGB2U32(rgb.r, rgb.g, rgb.b);  
21.	                PutPixel(j, i, oldcolor);  
22.	            }  
23.	        }  
24.	    }  
25.	    else  
26.	    {  
27.	        //范围超出  
28.	        return -1;  
29.	    }  
30.	    return 0;  
31.	}  
32.	  
33.	u8 ContrastCalc(u8 color,int param)  
34.	{  
35.	    int tcolor;  
36.	    if (param > 50 || param < -50)  
37.	    {  
38.	        //如果输入调节参数超出限制范围  
39.	        return -1;  
40.	    }  
41.	    tcolor = -1.29 * param * pow(color, 3) * 1e-6 + 4.93 * param * pow(color, 2) * 1e-4 + (1 - 4.18 * param * 1e-2) * color;  
42.	    //函数原型为：f(x)=a*x^3+bx^2+cx，通过此函数模拟“S”型灰度曲线。  
43.	    if (tcolor > 255)  
44.	    {  
45.	        return 255;  
46.	    }  
47.	    else if (tcolor < 0)  
48.	    {  
49.	        return 0;  
50.	    }  
51.	    else  
52.	    {  
53.	        return tcolor;  
54.	    }  
55.	}  
###### 饱和度调节算法
 
图八：饱和度调节函数曲线

饱和度实现的原理：
	饱和度调节函数通过模拟指数型曲线，改变图像的色彩值：如果saturation < 1，则图像中所有像素的饱和度将增加；如果saturation > 1，则图像中所有像素的饱和度将减小；如果saturation = 1，则图像不变。
	饱和度调节的过程：第一步，判断当前图像的饱和度是否为1，如果不为1，则计算饱和度变化的倍率（本次的饱和度=选定的饱和度/上次的饱和度）；如果为1，则直接进入第二步。第二步，将计算后的倍率作为参数调节图像的饱和度。
饱和度调节公式见下： 
  
图九：饱和度调节效果图

###### 亮度调节算法
亮度调节与饱和度调节相似，公式为：
 
图十：亮度调节效果图

1.	int ImageLightness(BMPATTR attr, double times)  
2.	{  
3.	    int i, j;       //循环变量  
4.	    u32 oldcolor;   //色彩变量  
5.	    RGB rgb;        //色彩分量  
6.	    HSL hsl;        //色彩分量  
7.	  
8.	    if (times <= 4 && times >= 0.25)  
9.	    {     
10.	        for (i = attr.y1; i < attr.y2; i++)  
11.	        {  
12.	            for (j = attr.x1; j < attr.x2; j++)  
13.	            {  
14.	                oldcolor = GetPixel(j, i);  
15.	                //类型转换  
16.	                U32TRGB(&rgb, oldcolor);  
17.	                RGB2HSL(rgb, &hsl);  
18.	  
19.	                //计算公式  
20.	                hsl.l = pow(hsl.l, 1 / times);  
21.	  
22.	                //类型转换  
23.	                HSL2RGB(&rgb, hsl);  
24.	                oldcolor = RGB2U32(rgb.r, rgb.g, rgb.b);  
25.	  
26.	                PutPixel(j, i, oldcolor);  
27.	            }  
28.	        }  
29.	    }  
30.	    else  
31.	    {  
32.	        //范围超出  
33.	        return -1;  
34.	    }  
35.	    return 0;  
36.	}  
 
#### 6.4渐变滤镜算法
###### 渐变算法
首先将颜色值转换为RGB，再转换为HSL，根据起始颜色和终止颜色的HSL值以及渐变图形的高度，计算出每一行的色相、饱和度、亮度各变化量：
 
由于亮度和饱和度均为double型，故每一行直接增加一个微小的增量（dLightness、dSaturation）即可。而对于int型的变量色相，直接加dHue相对于加0，其色相并不会改变，故需要从起始值开始累计增量，且需要四舍五入保留整数部分：
 
代码如下：
1.	void ImgShading(int x1, int y1, int x2, int y2, u32 color1, u32 color2)  
2.	{  
3.	    int i = 0, j = 0;           //循环变量  
4.	    int temp1, temp2;           //用于交换的临时变量  
5.	    HSL tHSL1, tHSL2;           //存储HSL的临时变量  
6.	    RGB tRGB1, tRGB2;           //存储RGB的临时变量  
7.	    int tHue0;                  //用于计算色相的临时变量  
8.	    double dLightness;          //每行渐变的亮度的值  
9.	    double dSaturation;         //每行渐变的饱和度的值  
10.	    double dHue;                //每行渐变的色相的值  
11.	  
12.	    U32TRGB(&tRGB1, color1);    //获取color的RGB值  
13.	    U32TRGB(&tRGB2, color2);  
14.	    RGB2HSL(tRGB1, &tHSL1);     //将RGB转化为HSL  
15.	    RGB2HSL(tRGB2, &tHSL2);  
16.	  
17.	    tHue0 = tHSL1.h;                                      //赋初值  
18.	  
19.	    dLightness = (tHSL2.l - tHSL1.l) / fabs(y1 - y2);     //计算每行渐变的亮度的值  
20.	    dSaturation = (tHSL2.s - tHSL1.s) / fabs(y1 - y2);    //计算每行渐变的饱和度的值  
21.	    dHue = (tHSL2.h - tHSL1.h) / fabs(y1 - y2);           //计算每行渐变的色相的值  
22.	  
23.	    delay(100);  
24.	  
25.	    /*确保x1 < x2*/  
26.	    if (x1 > x2)  
27.	    {  
28.	        temp1 = x1;  
29.	        x1 = x2;  
30.	        x2 = temp1;  
31.	    }  
32.	  
33.	    /*确保y1 < y2*/  
34.	    if (y1 > y2)  
35.	    {  
36.	        temp2 = y1;  
37.	        y1 = y2;  
38.	        y2 = temp2;  
39.	    }  
40.	  
41.	    //渐变背景  
42.	    for (i = y1; i < y2; i++)  
43.	    {  
44.	        for (j = x1; j < x2; j++)  
45.	        {  
46.	            PutPixel(j, i, color1);  
47.	        }  
48.	  
49.	        /*计算渐变一行后的HSL值*/  
50.	        tHSL1.l = tHSL1.l + dLightness;  
51.	        tHSL1.s = tHSL1.s + dSaturation;  
52.	        tHSL1.h = (int)(tHue0 + dHue * i + 0.5);  
53.	  
54.	        HSL2RGB(&tRGB1, tHSL1);                         //将HSL转化为RGB  
55.	        color1 = RGB2U32(tRGB1.r, tRGB1.g, tRGB1.b);    //将RGB转化为颜色值赋给color  
56.	    }  
57.	}  

###### 混合算法
叠加模式通过分析基色每个通道的数值，对颜色进行正片叠加或滤色混合，结果色保留基色的明暗对比，因此结果色以基色为主导。计算公式：
 从公式可以看出，结果色会根据基色的颜色数值选择不同的计算公式。
叠加在保留底色明暗变化的基础上还能使绘图的颜色被叠加到底色上，但保留底色的高光和阴影部分。底色的颜色没有被取代，而是和绘图色混合来体现原图的亮部和暗部。使用此模式可使底色的图像的饱和度及对比度得到相应的提高，使图像看起来更加鲜亮。
但单纯叠加会导致图像的饱和度和对比度过高，因此还需要在叠加之后再按照原图与新图7：3的比例将二者混合：
const double percent = 0.7;    //混合时背景图案所占的比例
tRGB.r = (unsigned char)(percent * tRGB1.r + (1 - percent) * tRGB.r);
	tRGB.g = (unsigned char)(percent * tRGB1.g + (1 - percent) * tRGB.g);
tRGB.b = (unsigned char)(percent * tRGB1.b + (1 - percent) * tRGB.b);

代码如下：
1.	void ImgMix(int x1, int y1, int x2, int y2, u32 color1, u32 color2)  
2.	{  
3.	    int i, j;                      //循环变量  
4.	    int temp1, temp2;              //用于交换的临时变量  
5.	    const double percent = 0.7;    //混合时背景图案所占的比例  
6.	    u32 color_scr1;                //用于获取背景图案的颜色值  
7.	    u32 color_scr2;                //用于获取渐变矩形的颜色值  
8.	    u32 color_dst;                 //用于计算所得结果的颜色值  
9.	    RGB tRGB;                      //将计算结果的颜色值转化为RGB  
10.	    RGB tRGB1;                     //将背景图案的颜色值转化为RGB  
11.	    RGB tRGB2;                     //将渐变矩形的颜色值转化为RGB  
12.	    FILE* fp;                      //将背景图案每一点的颜色值读取出来存入文件中，再从文件中读取颜色值用于计算  
13.	  
14.	    /*以二进制只写模式打开临时文件，如果文件打开失败，退出*/  
15.	    if ((fp = fopen("DATA//temp2", "wb")) == NULL)  
16.	    {  
17.	        exit(0);  
18.	    }  
19.	  
20.	    /*确保x1 < x2*/  
21.	    if (x1 > x2)  
22.	    {  
23.	        temp1 = x1;  
24.	        x1 = x2;  
25.	        x2 = temp1;  
26.	    }  
27.	  
28.	    /*确保y1 < y2*/  
29.	    if (y1 > y2)  
30.	    {  
31.	        temp2 = y1;  
32.	        y1 = y2;  
33.	        y2 = temp2;  
34.	    }  
35.	  
36.	    /*读取每一点的颜色值，并写入文件*/  
37.	    for (j = y1; j < y2; j++)  
38.	    {  
39.	        for (i = x1; i < x2; i++)  
40.	        {  
41.	            color_scr1 = GetPixel(i, j);  
42.	            fwrite(&color_scr1, 4, 1, fp);  
43.	        }  
44.	    }  
45.	  
46.	    fclose(fp);    //关闭文件  
47.	  
48.	    ImgShading(x1, y1, x2, y2, color1, color2);    //画渐变矩形  
49.	  
50.	    /*以二进制只读模式打开临时文件，如果文件打开失败，退出*/  
51.	    if ((fp = fopen("DATA//temp2", "rb")) == NULL)  
52.	    {  
53.	        exit(0);  
54.	    }  
55.	  
56.	    /*将背景图案的颜色值读出后，与渐变矩形的RGB按一定比例混合*/  
57.	    for (j = y1; j < y2; j++)  
58.	    {  
59.	        for (i = x1; i < x2; i++)  
60.	        {  
61.	            /*分别获取背景图案和渐变矩形的颜色值，并将其转化为RGB*/  
62.	            fread(&color_scr1, 4, 1, fp);  
63.	            color_scr2 = GetPixel(i, j);  
64.	            U32TRGB(&tRGB1, color_scr1);  
65.	            U32TRGB(&tRGB2, color_scr2);  
66.	  
67.	            /*计算混合后的RGB*/  
68.	            if (tRGB1.r <= 128)  
69.	            {  
70.	                tRGB.r = (unsigned char)(tRGB1.r * tRGB2.r / 128);  
71.	            }  
72.	            else  
73.	            {  
74.	                tRGB.r = (unsigned char)(255 - (255 - tRGB1.r) * (255 - tRGB2.r) / 128);  
75.	            }  
76.	  
77.	            if (tRGB1.g <= 128)  
78.	            {  
79.	                tRGB.g = (unsigned char)(tRGB1.g * tRGB2.g / 128);  
80.	            }  
81.	            else  
82.	            {  
83.	                tRGB.g = (unsigned char)(255 - (255 - tRGB1.g) * (255 - tRGB2.g) / 128);  
84.	            }  
85.	  
86.	            if (tRGB1.b <= 128)  
87.	            {  
88.	                tRGB.b = (unsigned char)(tRGB1.b * tRGB2.b / 128);  
89.	            }  
90.	            else  
91.	            {  
92.	                tRGB.b = (unsigned char)(255 - (255 - tRGB1.b) * (255 - tRGB2.b) / 128);  
93.	            }  
94.	  
95.	            tRGB.r = (unsigned char)(percent * tRGB1.r + (1 - percent) * tRGB.r);  
96.	            tRGB.g = (unsigned char)(percent * tRGB1.g + (1 - percent) * tRGB.g);  
97.	            tRGB.b = (unsigned char)(percent * tRGB1.b + (1 - percent) * tRGB.b);  
98.	  
99.	            /*将混合后的RGB转化为颜色值，并画点*/  
100.	            color_dst = RGB2U32(tRGB.r, tRGB.g, tRGB.b);  
101.	            PutPixel(i, j, color_dst);  
102.	        }  
103.	    }  
104.	  
105.	    fclose(fp);    //关闭文件  
106.	}  
  
 
#### 6.5 Bresenham算法
###### 画直线算法
    由于显示直线的象素点只能取整数值坐标，可以假设直线上第i个象素点坐标为(xi，yi)，它是直线上点(xi，yi)的最佳近似，并且xi=xi(假设m<1），如下图所示。那么，直线上下一个象素点的可能位置是(xi+1，yi)或(xi+1，yi+1)。
 
 
　　由图中可以知道，在x=xi+1处，直线上点的y值是y=m(xi+1)+b，该点离象素点(xi+1，yi)和象素点(xi+1，yi+1)的距离分别是d1和d2： 
 
d1=y-yi=m(xi+1)+b-yi	(2－8)
d2=(yi+1)-y=(yi+1)-m(xi+1)-b	(2－9)
　　这两个距离差是
d1-d2=2m(xi+1)-2yi＋2b-1	(2－10)

　　我们来分析公式(2-10)：
　　(1)当此值为正时，d1>d2，说明直线上理论点离(xi+1，yi+1)象素较近，下一个象素点应取(xi+1，yi+1)。
　　(2)当此值为负时，d1<d2，说明直线上理论点离(xi+1，yi)象素较近，则下一个象素点应取(xi+1，yi)。
　　(3)当此值为零时，说明直线上理论点离上、下两个象素点的距离相等，取哪个点都行，假设算法规定这种情况下取(xi+1，yi+1)作为下一个象素点。
　　因此只要利用(d1-d2)的符号就可以决定下一个象素点的选择。为此，我们进一步定义一个新的判别式：
pi=△x×(d1-d2)=2△y·xi-2△x·yi+c	(2－11)

　　式(2-11)中的△x=(x2-x1)>0，因此pi与(d1-d2)有相同的符号；
　　这里△y=y2-y1，m=△y/△x；c=2△y+△x(2b-1)。
　　下面对式(2-11)作进一步处理，以便得出误差判别递推公式并消除常数c。
　　将式(2-11)中的下标i改写成i+1，得到：
pi+1=2△y·xi+1-2△x·yi+1+c	(2－12)
 
　　将式(2-12)减去(2-11)，并利用xi+1=xi+1，可得：
pi+1= pi+2△y-2△x·(yi+1-yi)	(2－13)
　　再假设直线的初始端点恰好是其象素点的坐标，即满足：
y1=mx1+b	(2－14)
　　由式(2-11)和式(2-14)得到p1的初始值：
p1=2△y-△x	(2－15)
　　这样，我们可利用误差判别变量，得到如下算法表示：
 	初始 　　　 p1=2△y-△x	(2－16)
	当pi≥0时： yi+1=yi+1,
　　　　　　xi+1=xi+1，
　　　　　　pi+1=pi+2(△y-△x)	
	否则：　　　yi+1=yi,
　　　　　　xi+1=xi+1， 
　　　　　　pi+1=pi+2△y	
 
　　从式(2-16)可以看出，第i+1步的判别变量pi+1仅与第i步的判别变量pi、直线的两个端点坐标分量差△x和△y有关，运算中只含有整数相加和乘2运算，而乘2可利用算术左移一位来完成，因此这个算法速度快并易于硬件实现。
代码如下：
1.	int Line(int x1, int y1, int x2, int y2, u32 color, u8 size)  
2.	{  
3.	    int x, y;  
4.	    int dx, dy;  
5.	    int s1, s2;  
6.	    int error;  
7.	    int temp;  
8.	    int interchange;  
9.	    int i;  
10.	  
11.	    x = x1;  
12.	    y = y1;  
13.	    dx = abs(x2 - x1);  
14.	    dy = abs(y2 - y1);  
15.	  
16.	    if (x2 > x1)  
17.	    {  
18.	        s1 = 1;  
19.	    }  
20.	    else  
21.	    {  
22.	        s1 = -1;  
23.	    }  
24.	  
25.	    if (y2 > y1)  
26.	    {  
27.	        s2 = 1;  
28.	    }  
29.	    else  
30.	    {  
31.	        s2 = -1;  
32.	    }  
33.	  
34.	    if (dy > dx)  
35.	    {  
36.	        temp = dx;  
37.	        dx = dy;  
38.	        dy = temp;  
39.	        interchange = 1;  
40.	    }  
41.	    else  
42.	    {  
43.	        interchange = 0;  
44.	    }  
45.	  
46.	    error = 2 * dy - dx;  
47.	  
48.	    for (i = 1; i <= dx; i++)  
49.	    {  
50.	        DrawPixel(x, y, color, size);    //画点  
51.	  
52.	        if (error >= 0)  
53.	        {  
54.	            if (interchange == 0)  
55.	            {  
56.	                y = y + s2;  
57.	            }  
58.	            else  
59.	            {  
60.	                x = x + s1;  
61.	            }  
62.	  
63.	            error = error - 2 * dx;  
64.	        }  
65.	  
66.	        if (interchange == 0)  
67.	        {  
68.	            x = x + s1;  
69.	        }  
70.	        else  
71.	        {  
72.	            y = y + s2;  
73.	        }  
74.	  
75.	        error = error + 2 * dy;  
76.	    }  
77.	  
78.	    return 1;  
79.	}  

###### 画圆算法
 
显然，我们只需要知道了圆上的一个点的坐标 (x, y) ，利用八对称性，我们马上就能得到另外七个对称点的坐标。
和直线算法类似，Bresenham画圆算法也是用一系列离散的点来近似描述一个圆，如下图。
 
 
Bresenham画圆算法的流程图如下：
 
可以看到，与画线算法相比，画圆的循环中用到了整数的乘法，相对复杂了一些。
代码如下：
1.	int Circle(int x, int y, int r, u32 color, u8 size)  
2.	{  
3.	    int a = 0;  
4.	    int b = r;  
5.	    int error = 3 - 2 * r;  
6.	  
7.	    while (a <= b)  
8.	    {  
9.	        DrawCircle_8(x, y, a, b, color, size);  
10.	  
11.	        if (error < 0)  
12.	        {  
13.	            error = error + 4 * a + 6;  
14.	        }  
15.	        else  
16.	        {  
17.	            error = error + 4 * (a - b) + 10;  
18.	            b--;  
19.	        }  
20.	  
21.	        a++;  
22.	    }  
23.	  
24.	    return 1;  
25.	}  
26.	  
27.	void DrawCircle_8(int x, int y, int a, int b, u32 color, u8 size)  
28.	{  
29.	    DrawPixel(x + a, y + b, color, size);  
30.	    DrawPixel(x - a, y + b, color, size);  
31.	    DrawPixel(x + a, y - b, color, size);  
32.	    DrawPixel(x - a, y - b, color, size);  
33.	    DrawPixel(x + b, y + a, color, size);  
34.	    DrawPixel(x - b, y + a, color, size);  
35.	    DrawPixel(x + b, y - a, color, size);  
36.	    DrawPixel(x - b, y - a, color, size);  
37.	}  
 
## 组员分工及时间安排

#### 7.1 组员分工
王子毅	底层编写：
1.	SVGA模式
2.	点阵字库
3.	BMP打开与保存
4.	色彩空间模型
功能设计：
1.	图片打开
2.	图片新建
3.	图片保存
4.	图库管理
5.	放缩功能
6.	放缩模式设置
7.	粗细设置
8.	调色板
9.	饱和度调整
10.	对比度调整
11.	亮度调整	

牛宝健 底层编写：
图形库
功能设计
1.	画笔
2.	图形
（直线、圆形、三角、
矩形）
3.	拾色器
4.	图像裁剪
5.	图像旋转
6.	图形镜像
7.	图像裁剪
8.	渐变滤镜
9.	登入界面	
 
#### 7.2 时间安排
第一周	查找相关资料，设计程序结构。	
第二周	查找相关资料，修改SVGA模块。	
第三周	初步设计图形界面。	
第四周	编写BMP文件读写底层函数，实现图像的打开及保存。	
第五周	设计照片管理模块：照片的打开、保存、新建、删除等。	
第六周	实现图像放缩、旋转、镜像、裁剪等基本功能。	
第七周	设计图像画笔功能，编写图形库。	

第八周	查找相关资料，建立色彩空间模型，实现RGB、HSL色彩空间转换。	
第九周	编写工具模块：拾色器、调色板、粗细调整。	
第十周	编写图像处理功能：调整对比度、饱和度、亮度。	
第十一周	实现图像渐变混合滤镜特效。	
第十二周	修改代码，优化算法。	
 
#### 7.2 代码行数
代码量总计：6230+336=6566行，其中组员王子毅的代码量为3306行，牛宝健的代码量为3306行。
文件名	代码量	牛保健	王子毅
bmp.c	311	0	311
box.c	389	289	100
color.c	653	240	413
draw.c	1833	1715	118
file.c	706	0	706
image.c	1427	423	1004
main.c	17	0	17
menu.c	255	0	255
pic.c	639	639	0
text.c	382	0	382
总代码量	6230	3306	3306
			
bmp.h	36		
box.c	32		
color.c	28		
draw.c	28		
file.h	30		
head.h	100		
image.h	38		
menu.h	20		
pic.h	24		
text.h	18		
总代码量	336		
			
svga.c	135		
svga.h	15		
 
## 总结
#### 8.1组员王子毅总结
暑假期间，我就开始了C语言程序设计。
因为我做的是照片管理与编辑系统，因此第一步要确定的是如何将一张图显示出来。通过查阅资料，我知道要不一张图显示出来，要使用SVGA模式。但是往届的代码SVGA模式都是16位的（5：6：5），而一般的BMP位图都是24位的（8：8：8），这样就出现了两种问题：1.图像颜色数据损失2.图像处理不方便，需要数值转换。因此我就开始寻找更好的SVGA模式。通过google搜索了一上午，我终于找到了一个文件VESA BIOS Extensions。
在这个文件中我发现SVGA其实是有全彩模式的，例如图中的115h和118h等。一开始我尝试了118h模式，但是屏幕中的一部分区域无法控制。后来尝试115h模式发现没有这个问题。于是我分析问题发现：BC31的显存为32*64kb=2Mb，但是118h模式下所需要的显存为：1024*768*4/1024/1024=3Mb,因此最后面的1Mb的像素无法控制，而115h模式下所需要的显存为：1.83Mb左右，因此可以实现。
完成了SVGA底层，然后就要实现BMP的读写。之后，我查找资料，学习BMP文件内部结构，最终成功地将BMP显示出来。
后来要写调色板，我决定要写一个可以选择所有颜色（2563种）的拾色器。查阅资料，如果要做这种调色板首先要实现HSL色彩空间与RGB色彩空间颜色转换的功能。于是，我进一步编写了色彩空间库（color.h），最终实现了这些功能。
后来我又在色彩空间库的基础上，写了饱和度、对比度、亮度算法，并协助队友做了渐变函数，滤镜功能等等。
C课设让我学习到了很多：从底层BISO的操作、SVGA的模式、点阵字库等等，到高级的算法：色彩空间转换、双线性插值法、图像混合模式等等。我从C课设中也学会了团队合作，如何通过GIT高效的管理代码、合并版本等等。还有程序设计的思想：各个模块的接口如何去做，才能实现对接。
正如爱尔兰曾经提到过，越是无能的人，越喜欢挑剔别人的错儿。所以我们不能抱怨C课设难度过大。池田大作说过一句著名的话，不要回避苦恼和困难，挺起身来向它挑战，进而克服它。虽然C课设难度比较大，但是我们就应该迎难而上。罗曼·罗兰说过一句著名的话，只有把抱怨环境的心情，化为上进的力量，才是成功的保证。带着这句话，我们不断在C课设的道路上前行。
 
#### 8.2组员牛宝健总结
本次课程设计是我第一次完整写一个应用软件程序，尽管只有短短的几个月时间，但我已经从上学期只会敲几十行代码的简单程序，到现在能够敲几千行代码，做出一个可以成功运行的小软件。感觉自己真的收获满满。
刚开始的时候，整个人对课程设计还没有概念，完全不知道自己应该从何入手，但随着与队友的沟通，自己在网上搜集资料、查找算法，自己也慢慢开始对整个课设有了一个总体的概念。但是从0到1的突破往往是不容易的，开学第一周的时候，我基本上都在和队友讨论该如何去实现我们的应用，分析应该将整个课设分为几个部分，明确各自的分工。在做好这些准备工作之后，我也就开始真刀真枪地去开始一行行地写代码了。真的，当我第一次写完自己的第一个函数，并且可以在BC上运行的时候，那种成就感真的是无以言表。
在实现了第一个函数功能之后，剩下函数的编写就似乎变得容易了许多，主要就是算法的设计问题。每当我写好一个函数之后，我都迫不及待在第一时间打开BC运行一下看看自己的成果。虽然基本上每次函数在第一次运行的时候，都会或多或少地出现这样那样的问题，但我都会一个一个耐心地debug。确实，在最初debug的时候，由于自己毫无经验，所以debug的过程也是万分痛苦的，但是每当我深陷一个bug无法自拔的时候，我的队友总会及时向我伸出援手，这也为我之后debug积累了不少经验。后来，随着功能的逐渐完善，我也在debug的过程中慢慢找寻到了一些规律，我的bug主要还是源于对鼠标的应用不够熟悉，在我一次又一次反复解决鼠标的各种问题的时候，我也渐渐掌握了与鼠标相关的各类函数的应用。
应该是我和我队友每次写一个功能之前都会先和对方商量一下的缘故，我们在合代码等方面都进行得十分顺利，而且遇到的bug也不算太多，都还在我们能解决的范围之内。不过到我们预验收的时候，学长觉得我们编写的功能过于简单，于是乎，最后一个星期，我们又加了许多功能，当然各类bug也如雨后春笋一般冒了出来。
但是，C课设不正是这样的吗？他所锻炼我们的，不仅仅是我们规范编写代码的能力，更多的是对我们意志力的一种磨练，对我们团队协作能力的一种锻炼。不得不承认，通过此次C课设，我的耐心、心态各方面都得到了很大的提高。从最初运行时出现了一个小小的bug就唉声叹气，各种抱怨怎么又出bug了，到现在即使是一次性出现了一大堆bug，我心里也只是觉得，不就是bug吗，一个一个该就好了嘛！
总的来说，这几个月的努力对我来说是一笔宝贵的财富，C课设让我学到的知识是全方面的，不仅是专业知识，更多的是为人处世的道理，他能让我们今后用更好的心态去面对那些比C课设要难的多的各种社会问题，让我们更好地在社会上立足。
 
## 代码
#### 9.1数据类型
1.	typedef unsigned char u8;  
2.	typedef unsigned int u16;  
3.	typedef unsigned long u32;  
4.	  
5.	  
6.	typedef unsigned int UINT16;  
7.	typedef unsigned long DWORD;  
8.	typedef long LONG;  
9.	typedef unsigned int WORD;  
10.	  
11.	  
12.	typedef struct {  
13.	    unsigned char r;        //范围0~255  
14.	    unsigned char g;        //范围0~255  
15.	    unsigned char b;        //范围0~255  
16.	} RGB;  
17.	  
18.	  
19.	typedef struct {  
20.	    int h;              //范围0~360  
21.	    double s;           //范围0~1  
22.	    double l;           //范围0~1  
23.	} HSL;  
24.	  
25.	  
26.	//文件属性  
27.	typedef struct {  
28.	    int flag;                       //文件状态  
29.	    char name[18];                  //文件名称  
30.	    double scale;                   //图像放缩  
31.	    int x1, y1;                     //图像坐标  
32.	    unsigned int width, heigth;     //图像长宽  
33.	    unsigned int nWidth, nHeigth;   //图像长宽  
34.	} FILEATTR;  
35.	  
36.	  
37.	//菜单状态  
38.	typedef struct {  
39.	    u8 size;        //画笔大小  
40.	    u8 size2;       //图形大小  
41.	    u8 patton;      //放大模式  
42.	    u32 color;      //颜色  
43.	} MENUSTATE;  
44.	  
45.	  
46.	//图像属性  
47.	typedef struct {  
48.	    int flag;                       //图像状态  
49.	    int save;                       //保存状态  
50.	    char name[18];                  //图像名称  
51.	    double scale;                   //图像放缩  
52.	    int x1, y1, x2, y2;             //图像坐标  
53.	    unsigned int width, heigth;     //当前长宽  
54.	    unsigned int oWidth, oHeigth;   //原始长宽  
55.	    int contrast;                   //对比度呀  
56.	    double saturation, lightness;   //调整属性  
57.	} BMPATTR;  

 
#### 9.2主函数
1.	#include "head.h"  
2.	#include "svga.h"  
3.	#include "mouse.h"  
4.	#include "menu.h"  
5.	  
6.	void main()  
7.	{  
8.	    SetSVGA();      //初始化SVGA  
9.	    MouseReset();   //初始化MOUSE  
10.	    Welcome();      //Weclome界面  
11.	    DrawMenu();     //WorkSpace界面  
12.	    MenuManager();  //消息管理机制  
13.	}  

#### 9.3消息管理机制
1.	void MenuManager()  
2.	{  
3.	    int message = 0;  
4.	    BMPATTR bmpattr = { 0,0,"",1.0,0,0,0,0,0,0,0,0 };  	//初始化图像属性
5.	    MENUSTATE state = { 5,1,0,0 };  					//初始化文件状态
6.	    MOUSE mouse_old, mouse_new;  
7.	    MouseStatus(&mouse_old);  
8.	    MouseStoreBk(mouse_old.x, mouse_old.y);  
9.	    while (1)  
10.	    {  
11.	        MouseStatus(&mouse_new);  
12.	        if (mouse_new.x == mouse_old.x && mouse_new.y == mouse_old.y && mouse_old.button == mouse_new.button)  
13.	            continue;  
14.	        else  
15.	        {  
16.	            MousePutBk(mouse_old.x, mouse_old.y);  
17.	            MouseStoreBk(mouse_new.x, mouse_new.y);  
18.	            MouseDraw(mouse_new);  
19.	  
20.	            mouse_old = mouse_new;  
21.	  
22.	            if (MouseDown(10, 0, 70, 50) || message == 20)  
23.	            {  
24.	                //打开  
25.	                MousePutBk(mouse_old.x, mouse_old.y);  
26.	                message = 20;  
27.	            }  
28.	            else if (MouseDown(70, 0, 130, 50) || message == 30)  
29.	            {  
30.	                //保存  
31.	                MousePutBk(mouse_old.x, mouse_old.y);  
32.	                message = 30;  
33.	            }  
34.	            else if (MouseDown(130, 0, 190, 50) || message == 40)  
35.	            {  
36.	                //新建  
37.	                MousePutBk(mouse_old.x, mouse_old.y);  
38.	                message = 40;  
39.	            }  
40.	            else if (MouseDown(190, 0, 250, 50) || message == 45)  
41.	            {  
42.	                //图库  
43.	                MousePutBk(mouse_old.x, mouse_old.y);  
44.	                message = 45;  
45.	            }  
46.	            else if (MouseDown(10, 50, 70, 100) || message == 50)  
47.	            {  
48.	                //画笔  
49.	                MousePutBk(mouse_old.x, mouse_old.y);  
50.	                message = 50;  
51.	            }  
52.	            else if (MouseDown(70, 50, 130, 100) || message == 60)  
53.	            {  
54.	                //裁剪  
55.	                MousePutBk(mouse_old.x, mouse_old.y);  
56.	                message=60;  
57.	            }  
58.	            else if (MouseDown(130, 50, 190, 100) || message == 65)  
59.	            {  
60.	                //图形  
61.	                MousePutBk(mouse_old.x, mouse_old.y);  
62.	                message = 65;  
63.	            }  
64.	            else if (MouseDown(650, 50, 700, 100) || message == 70)  
65.	            {  
66.	                //调整  
67.	                MousePutBk(mouse_old.x, mouse_old.y);  
68.	                message = 70;  
69.	            }  
70.	            else if (MouseDown(700, 50, 750, 100) || message == 75)  
71.	            {  
72.	                //粗细  
73.	                MousePutBk(mouse_old.x, mouse_old.y);  
74.	                message = 75;  
75.	            }  
76.	            else if (MouseDown(750, 50, 800, 100) || message == 80)  
77.	            {  
78.	                //调色板  
79.	                MousePutBk(mouse_old.x, mouse_old.y);  
80.	                message=80;  
81.	            }  
82.	            else if (MouseDown(703, 570, 735, 600) || message == 85)  
83.	            {  
84.	                //设置  
85.	                MousePutBk(mouse_old.x, mouse_old.y);  
86.	                message = 85;  
87.	            }  
88.	            else if (MouseDown(735, 570, 767, 600) || message == 90)  
89.	            {  
90.	                //缩小  
91.	                MousePutBk(mouse_old.x, mouse_old.y);  
92.	                message = 90;  
93.	            }  
94.	            else if (MouseDown(767, 570, 800, 600) || message == 95)  
95.	            {  
96.	                //放大  
97.	                MousePutBk(mouse_old.x, mouse_old.y);  
98.	                message = 95;  
99.	            }  
100.	            else if (MouseDown(0, 570, 42, 600) || message == 100)  
101.	            {  
102.	                //旋转  
103.	                MousePutBk(mouse_old.x, mouse_old.y);  
104.	                message = 100;  
105.	            }  
106.	            else if (MouseDown(42, 570, 84, 600) || message == 105)  
107.	            {  
108.	                //翻转  
109.	                MousePutBk(mouse_old.x, mouse_old.y);  
110.	                message = 105;  
111.	            }  
112.	            else if (MouseDown(84, 570, 126, 600) || message == 110)  
113.	            {  
114.	                //拾色器  
115.	                MousePutBk(mouse_old.x, mouse_old.y);  
116.	                message = 110;  
117.	            }  
118.	            else if(MouseDown(700, 0, 750, 50) || message == 120)  
119.	            {  
120.	                //滤镜  
121.	                MousePutBk(mouse_old.x, mouse_old.y);  
122.	                message = 120;  
123.	            }  
124.	            else if (MouseDown(750, 0, 800, 50))  
125.	            {  
126.	                //退出  
127.	                MousePutBk(mouse_old.x, mouse_old.y);  
128.	                Exit(&bmpattr);  
129.	                MouseStatus(&mouse_old);  
130.	                MouseStoreBk(mouse_old.x, mouse_old.y);  
131.	            }  
132.	            else  
133.	            {  
134.	                ;  
135.	            }  
136.	        }  
137.	        switch (message)  
138.	        {  
139.	            case 0:  
140.	                break;  
141.	            case 20:  
142.	                message = FileOpen(&bmpattr);  
143.	                MouseStatus(&mouse_old);  
144.	                MouseStoreBk(mouse_old.x, mouse_old.y);  
145.	                break;  
146.	            case 30:  
147.	                message = FileSave(&bmpattr);  
148.	                MouseStatus(&mouse_old);  
149.	                MouseStoreBk(mouse_old.x, mouse_old.y);  
150.	                break;  
151.	            case 40:  
152.	                message = FileNew(&bmpattr);  
153.	                MouseStatus(&mouse_old);  
154.	                MouseStoreBk(mouse_old.x, mouse_old.y);  
155.	                break;  
156.	            case 45:  
157.	                message = FileList(&bmpattr);  
158.	                MouseStatus(&mouse_old);  
159.	                MouseStoreBk(mouse_old.x, mouse_old.y);  
160.	                break;  
161.	            case 50:  
162.	                message = DrawPen(&bmpattr, &state);  
163.	                MouseStatus(&mouse_old);  
164.	                MouseStoreBk(mouse_old.x, mouse_old.y);  
165.	                break;  
166.	            case 60:  
167.	                //裁剪  
168.	                message = ImageTailor(&bmpattr);  
169.	                MouseStatus(&mouse_old);  
170.	                MouseStoreBk(mouse_old.x, mouse_old.y);  
171.	                break;  
172.	            case 65:  
173.	                //图形  
174.	                message = DrawPicture(&bmpattr, &state);  
175.	                MouseStatus(&mouse_old);  
176.	                MouseStoreBk(mouse_old.x, mouse_old.y);  
177.	                break;  
178.	            case 70:  
179.	                //调整  
180.	                message = ImageAdjustment(&bmpattr);  
181.	                MouseStatus(&mouse_old);  
182.	                MouseStoreBk(mouse_old.x, mouse_old.y);  
183.	                break;  
184.	            case 75:  
185.	                //粗细  
186.	                message = SelectSize(&state.size, &state.size2);  
187.	                MouseStatus(&mouse_old);  
188.	                MouseStoreBk(mouse_old.x, mouse_old.y);  
189.	                break;  
190.	            case 80:  
191.	                //选色  
192.	                message = SelectColor(&state.color);  
193.	                MouseStatus(&mouse_old);  
194.	                MouseStoreBk(mouse_old.x, mouse_old.y);  
195.	                break;  
196.	            case 85:  
197.	                //设置  
198.	                message = ImageZoomSet(&state.patton);  
199.	                MouseStatus(&mouse_old);  
200.	                MouseStoreBk(mouse_old.x, mouse_old.y);  
201.	                break;  
202.	            case 90:  
203.	                //缩小  
204.	                message = ImageZoom(&bmpattr, 0.8, state.patton);  
205.	                MouseStatus(&mouse_old);  
206.	                MouseStoreBk(mouse_old.x, mouse_old.y);  
207.	                break;  
208.	            case 95:  
209.	                //放大  
210.	                message = ImageZoom(&bmpattr, 1.25, state.patton);  
211.	                MouseStatus(&mouse_old);  
212.	                MouseStoreBk(mouse_old.x, mouse_old.y);  
213.	                break;  
214.	            case 100:  
215.	                //旋转  
216.	                message = ImageRot(&bmpattr);  
217.	                MouseStatus(&mouse_old);  
218.	                MouseStoreBk(mouse_old.x, mouse_old.y);  
219.	                break;  
220.	            case 105:  
221.	                //翻转  
222.	                message = ImageMirror(bmpattr);  
223.	                MouseStatus(&mouse_old);  
224.	                MouseStoreBk(mouse_old.x, mouse_old.y);  
225.	                break;  
226.	            case 110:  
227.	                //拾色器  
228.	                message = PickColor(&state.color,0);  
229.	                MouseStatus(&mouse_old);  
230.	                MouseStoreBk(mouse_old.x, mouse_old.y);  
231.	                break;  
232.	            case 120:  
233.	                //滤镜  
234.	                message = DrawShading(&bmpattr);  
235.	                MouseStatus(&mouse_old);  
236.	                MouseStoreBk(mouse_old.x, mouse_old.y);  
237.	                break;  
238.	            default:  
239.	                break;  
240.	        }  
241.	    }  
242.	}  
